---
layout: post
title: 《学习微服务》01、从单体应用到微服务
---

微服务在近几年突然就火了起来，虽然它概念已经提出提出有很久了，可能是随着互联网服务的演进，各大公司不断的尝试，积累到了一个阈值，最佳实践应运而生。  
虽然可能学了也没机会实践，但是技术人还是要跟上技术的热潮。所以我也借学习极客时间的[《从 0 开始学微服务》](https://time.geekbang.org/column/intro/115)专栏的机会，开始这个系列博客，权当个学习体会。

---

## 单体应用

现在我自己工作或自己业余作品都还在单体应用的范畴，小公司嘛。单体应用 Java 派系的 MVC（Spring + mybatis + tomcat），学习成本低上手快，甚至一个人都可以搞定开发、测试、部署、运维一整套流程。单体应用架构适合初创公司小规模团队的项目快速验证阶段。  
如果项目发展好，团队增长壮大，单体应用架构的弊端就会逐渐显现：

- **团队协作开发难**。初期二三人，合作尚且要靠每个人的能力过关，习惯良好。团队增长，不可控因素变多，同时在一套代码上开发，即便依靠 git 等工具，也会经常产生各种冲突，即便自己的代码测试通过，别人新提交的代码也会影响最终结果，只要有一个人出了 bug，就必须等待其解决后才能继续下一步操作，大大降低了开发效率。
- **部署效率低**。代码越写越多，测试代码也越来越多，依赖也越来越多，编译打包到部署测试的时间越来越长。Java 的口号是：Build once, run everywhere. **一次编译，随处运行**。但是项目代码膨胀后的 Java 程序员也可以做到：Build once, run everywhere. **一次编译，（有足够时间）到处跑跑**。听说微软 Office 的一次编译要按小时算？
- **系统高可用性差**。所有的代码都是打成 war 包扔进 Tomcat，运行在单个 tomcat 进程中。即便只是某一小处出现了问题，也可能引起整个系统的瘫痪。今天中午在买很火的 lxxkin 咖啡时，他们的服务就嗝屁了 10 多分钟才恢复正常，不知损失了多少订单。
- **线上发布慢**。代码膨胀带来的副作用，服务启动时间变长。如果启动服务需要 10 分钟，机器规模 100 台，每次发布的步长 10%，单次发布就需要至少 100 分钟。

从代码层面看，如果代码腐烂了，就会越变越差，通过设计模式的解耦加以重构，才能保持代码质量持续良好。所以服务出现了上述问题，就说明可能需要引入某种方案来解耦重构整个系统的架构。所以**服务化**来了。

## 服务化

服务化就是把单体应用中 jar 包依赖产生的本地方法调用，改造成通过 RPC 接口使用的远程方法调用。将系统从纵向或横向抽象成多个模块，可以按业务流程划分，也可以按资源依赖程度划分。这样，每个模块都可以交给专门团队单独的开发、测试、部署、运维。每个团队管好自己的一亩三分地，对外做好服务就行了。  
这就解决了单体应用膨胀，团队开发高耦合，协作效率低的问题。

## 微服务

Docker 的成熟与 DevOps 文化的兴起，促进了微服务的发展。  
相比服务化，微服务又更进了一步。微服务主要有以下几个特点：

- **服务拆分粒度更细**。微服务是更细粒度的而服务化。只要一个子模块依赖的资源和其他模块没关系，就可以独立成一个微服务。
- **服务独立部署**。每个微服务都独立打包部署。借助 docker，可以在一台物理机上运行多个 docker 实例，每个 docker 实例可以部署一个微服务。
- **服务独立维护**。每个微服务都可以交给更小的团队开发、测试、部署、运维，对其整个生命周期负责。
- **服务治理能力要求高**。拆分带来的副作用，拆得越多九月急需一个负责调度的中心。微服务数量变多，就需要一个统一的服务治理平台，来管理各个服务。

（在公司有足够的人才资源的前提下）微服务化可以更进一步的提高需求交付的效率（例：我只想升级一下用户头像的功能点，只会涉及用户头像微服务的变动），提升高可用性，提搞团队协作效率，提高部署效率等好处。

## 总结

随着移动互联网的发展，敏捷开发、持续交付、DevOps 的发展与实践以及 Docker 容器化技术的成熟，促成了微服务架构的流行。微服务就是将复杂的单体应用进行细粒度的服务化拆分，每个服务都交由小团队单独维护整个生命周期，提高了交付效率。

我相信，每种技术在解决问题的同时也会引入新的挑战。
